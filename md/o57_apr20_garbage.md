โจทย์ต้องการให้หาว่า หากต้องการเดินทางบน undirected, weighted graph จาก node $P_j$ ไปยัง $Q_j$ จะทำให้เส้นที่เดินผ่านที่มีน้ำหนักมากที่สุด มีน้ำหนักน้อยที่สุดได้เท่าไร

หากเราพิจารณาแต่ละคำถามแยกกัน เราสามารถหาคำตอบได้โดยเรียงน้ำหนักเส้นเชื่อมจากน้อยไปมาก ค่อย ๆ เติมเส้นเชื่อมเข้าไปในกราฟทีละเส้นจนกว่า $P_j$ กับ $Q_j$ จะเชื่อมกันแล้วตอบน้ำหนักเส้นเชื่อม ณ เวลานั้น คล้าย ๆ กับการหา Minimum Spanning Tree (การเติมเส้นเชื่อมและตรวจสอบการเชื่อมกันทำได้โดยใช้ Union-find Disjoint Set)

หากต้องทำกระบวนการเช่นนี้ซ้ำทุกครั้งที่พิจารณาคำถามใหม่จะเสียเวลา ดังนั้นเราต้องหาวิธีตอบคำถามทั้งหมดให้ได้โดยทำกระบวนการนี้เป็นจำนวนน้อยครั้ง

ในที่นี้ จะเสนอสองวิธีด้วยกัน

## Solution 1: Union by Rank

สามารถแก้ปัญหานี้ได้โดยใช้ Union-find Disjoint Set แบบใช้ Union by Rank แต่**ไม่ใช้ Path Compression** โดยทุกครั้งที่รวม component $v$ เข้าไปใน component $u$ นอกจากจะกำหนดให้ parent ของ $v$ เท่ากับ $u$ แล้ว ให้ใส่หมายเลขกำกับไปอีกด้วยว่าเป็นการเชื่อมด้วยเส้นเชื่อมน้ำหนักเท่าใด สุดท้ายจะได้โครงสร้างของ Union-find Disjoint Set มีลักษณะเป็น weighted, rooted tree

เมื่อทำเช่นนี้แล้ว การตอบคำถามที่ $j$ สามารถทำได้โดยหา edge ที่มากที่สุดบน path จาก $P_j$ ไป $Q_j$ บนต้นไม้ที่เกิดจาก Union-find Disjoint Set ซึ่งสามารถหาได้ในเวลา $O(\log N)$ ด้วยเทคนิค [Binary Lifting](https://www.geeksforgeeks.org/lca-in-a-tree-using-binary-lifting-technique/)

เนื่องจาก Union by Rank ใช้เวลารวมหรือตรวจสอบครั้งละ $O(\log N)$ amortized และเราต้องตอบคำถาม $Q$ ครั้ง แต่ละครั้งใช้เวลา $O(\log N)$ ในการตอบ จะได้ Time Complexity ทั้งหมดเป็น $O((M+Q) \log N)$

## Solution 2: Parallel Binary Search

สมมุติว่าเราต้องการตอบแต่ละคำถามด้วยวิธี Binary Search นั่นคือ เราจะกำหนดให้ edge ที่หนักที่สุดที่เดินผ่านได้มีน้ำหนักเป็น $x$ แล้วหาว่ามีเส้นทางจาก $P_j$ ไป $Q_j$ หรือไม่ด้วยวิธี Minimum Spanning Tree ดังที่กล่าวไว้ตอนต้นของเฉลยนี้ หากทำได้เราสามารถทดลองค่า $x$ ที่น้อยลง แต่หากไม่ได้ให้ทดลองค่า $x$ ที่มากขึ้น เพื่อหาค่า $x$ ที่น้อยที่สุดที่ทำได้

แน่นอนว่าวิธีนี้ซับซ้อนเกินความจำเป็น เพราะแทนที่จะ Binary Search เราสามารถทำ Minimum Spanning Tree เพียงรอบเดียวแล้วตอบคำถามระหว่างทำได้เลย แต่ว่าการคิดเช่นนี้ทำให้เราต่อยอดนำไปลด Time Complexity รวมของโจทย์ทั้งหมดได้

สังเกตว่าในแต่ละคำถาม หากเราใช้วิธีนี้ ขั้นแรกของ binary search คือการทดลองค่า $x$ กลางช่วง $[1, 10^9]$ เหมือนกันทั้งหมด และในขั้นที่สอง คำถามบางกลุ่มจะพิจารณาช่วง $[1, \frac{10^9}{2}]$ และอีกกลุ่มจะพิจารณาช่วง $[\frac{10^9}{2}+1, 10^9]$ และเช่นเดียวกันในขั้นอื่น ๆ คำถามทั้งหมดจะถามในช่วงที่เหมือน ๆ กันเสมอ

ดังนั้น แทนที่เราจะต้องทำ Minimum Spanning Tree แยกแต่ละคำถาม เราสามารถจัดกลุ่มคำถามตามช่วงที่พิจารณา แล้วทำ Minimum Spanning Tree เพียงครั้งเดียวต่อขั้นของ binary search ได้ ลักษณะการทำงานคร่าว ๆ จะเป็นดังนี้

- ในขั้นแรก ทุกคำถามพิจารณาช่วง $[1, 10^9]$ เหมือนกันหมด ดังนั้นให้ทำ Minimum Spanning Tree จนถึงเส้นเชื่อมที่มีน้ำหนักไม่เกิน $\frac{10^9}{2}$ แล้วตรวจสอบว่าคำถามใดจะต้องพิจารณาคำตอบในช่วง $[1, \frac{10^9}{2}]$ และคำถามใดจะต้องพิจารณาคำตอบในช่วง $[\frac{10^9}{2}+1, 10^9]$
- ขั้นที่สอง ให้เริ่มทำ Minimum Spanning Tree ใหม่ ทำไปเรื่อย ๆ จนถึงประมาณ $\frac{10^9}{4}$ (กึ่งกลางช่วงแรก) แล้วแบ่งคำถามกลุ่มแรกออกเป็นสองกลุ่ม แล้วทำ Minimum Spanning Tree ต่อไปเรื่อย ๆ จนถึงประมาณ $\frac{3}{4} \cdot 10^9$ เพื่อแบ่งคำถามกลุ่มที่สองออกเป็นสองกลุ่ม
- ขั้นที่สามเป็นต้นไป ทำ Minimum Spanning Tree ไปเรื่อย ๆ โดยหยุดทุกครั้งที่ถึงกึ่งกลางช่วง binary search ของขั้นนั้นแล้วแบ่งคำถามออกเป็นสองกลุ่ม
- ทำเช่นนี้ไปเรื่อย ๆ จนกว่าจะถึง binary search ขั้นสุดท้ายที่แต่ละคำถามมีคำตอบเป็นจำนวนเต็มเพียงตัวเดียว

เนื่องจาก
- การแบ่งช่วง binary search สามารถแบ่งได้มากสุดเพียง $O(\log 10^9)$ ขั้น
- แต่ละขั้นต้องหา Minimum Spanning Tree ใน $O(M \cdot \alpha (N))$ และพิจารณาตอบ $Q$ คำถาม คำถามละ $O(1)$
- ก่อนทำขั้นตอนวิธีนี้ทั้งหมด จะต้องเรียงลำดับเส้นเชื่อมใน $O(M \log M)$

ทำให้ได้ time complexity ทั้งหมดเป็น $O(M \log M + (M \cdot \alpha (N) +Q) \log 10^9)$
